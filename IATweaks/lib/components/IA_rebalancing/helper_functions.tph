DEFINE_PATCH_FUNCTION ~S!ITMSPL_USES_OPCODE~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
    header_length = 0x38    // 0x38 for item, 0x28 for spell
  RET
    is_found
    opcode_resource
BEGIN
  SPRINT is_found "FALSE"
  SPRINT opcode_resource ""
  READ_LONG 0x6a fx_off
  PATCH_IF (check_globals = 1) BEGIN
    READ_SHORT 0x70 fx_num
    FOR (index = 0 ; index < fx_num ; ++index) BEGIN
      READ_SHORT (fx_off +        (index * 0x30)) opcode_file
      READ_ASCII (fx_off + 0x14 + (index * 0x30)) res_name
      PATCH_IF (match_opcode = opcode_file) BEGIN
        ///PATCH_PRINT ~File uses opcode %match_opcode% with res %res_name% in global effects~///
        SPRINT is_found "TRUE"
        SPRINT opcode_resource "%res_name%"
      END
    END
  END
  PATCH_IF (check_headers = 1) BEGIN
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    SET loop_start = 0
    SET loop_end = abil_num
    FOR (index2 = loop_start ; index2 < loop_end ; ++index2) BEGIN // looks through headers
      READ_BYTE (abil_off +        (index2 * header_length)) abil_type
      READ_SHORT (abil_off + 0x1e + (index2 * header_length)) abil_fx_num
      READ_SHORT (abil_off + 0x20 + (index2 * header_length)) abil_fx_idx
      FOR (index = 0 ; index < abil_fx_num ; index = index + 1) BEGIN
        READ_SHORT (fx_off +        ((abil_fx_idx + index) * 0x30)) opcode_file
        READ_ASCII (fx_off + 0x14 + ((index + abil_fx_idx) * 0x30)) res_name
        PATCH_IF (match_opcode = opcode_file) BEGIN
          SPRINT is_found "TRUE"
          SPRINT opcode_resource "%res_name%"
          index=abil_fx_num
        END
      END
    END
  END
END

DEFINE_PATCH_FUNCTION ~S!SPELL_USES_OPCODE~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
  RET
    is_found
    opcode_resource
BEGIN
  LPF ~S!ITMSPL_USES_OPCODE~
    INT_VAR
      check_globals  = 1
      check_headers  = 1
      match_opcode   = %match_opcode%
      header_length = 0x28
    RET is_found opcode_resource
  END
END

DEFINE_PATCH_FUNCTION ~S!ITEM_USES_OPCODE~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
    header_length = 0x38    // 0x38 for item, 0x28 for spell
  RET
    is_found
    opcode_resource
BEGIN
  LPF ~S!ITMSPL_USES_OPCODE~
    INT_VAR
      check_globals  = 1
      check_headers  = 1
      match_opcode   = %match_opcode%
      header_length = 0x38
    RET is_found opcode_resource
  END
END

DEFINE_ACTION_FUNCTION ~S!ADD_SPLPROT_2DA_ENTRY~
  STR_VAR
    condition_description = ~~
    stat                  = ~~
    value                 = ~~
    relation              = ~~
  RET
    new_line_number
BEGIN
  COPY_EXISTING ~splprot.2da~ ~override/splprot.2da~
    COUNT_2DA_COLS ~colcount~
    COUNT_2DA_ROWS ~colcount~ ~rowcount~

    SPRINT new_line_number ~%rowcount%~
    INSERT_2DA_ROW ~rowcount~ ~colcount~ EVAL ~%condition_description% %stat% %value% %relation%~
    PRETTY_PRINT_2DA
  OUTER_SPRINT new_line_number ~%rowcount%~
END

DEFINE_PATCH_FUNCTION ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_SPLITM~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
    header_length = 0x38    // 0x38 for item, 0x28 for spell
  RET_ARRAY
    all_resources
BEGIN
  DEFINE_ASSOCIATIVE_ARRAY all_resources BEGIN
  END
  READ_LONG 0x6a fx_off
  PATCH_IF (check_globals = 1) BEGIN
    READ_SHORT 0x70 fx_num
    FOR (index = 0 ; index < fx_num ; ++index) BEGIN
      READ_SHORT (fx_off +        (index * 0x30)) opcode_file
      READ_ASCII (fx_off + 0x14 + (index * 0x30)) res_name
      PATCH_IF (match_opcode = opcode_file) AND NOT VARIABLE_IS_SET $all_resources("%res_name%") BEGIN
        SPRINT $all_resources("%res_name%") "set"
      END
    END
  END
  PATCH_IF (check_headers = 1) BEGIN
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    SET loop_start = 0
    SET loop_end = abil_num
    FOR (index2 = loop_start ; index2 < loop_end ; ++index2) BEGIN // looks through headers
      READ_BYTE (abil_off +        (index2 * header_length)) abil_type
      READ_SHORT (abil_off + 0x1e + (index2 * header_length)) abil_fx_num
      READ_SHORT (abil_off + 0x20 + (index2 * header_length)) abil_fx_idx
      FOR (index = 0 ; index < abil_fx_num ; index = index + 1) BEGIN
        READ_SHORT (fx_off +        ((abil_fx_idx + index) * 0x30)) opcode_file
        READ_ASCII (fx_off + 0x14 + ((index + abil_fx_idx) * 0x30)) res_name
        PATCH_IF (~%match_opcode%~ = ~%opcode_file%~) AND NOT VARIABLE_IS_SET $all_resources("%res_name%") BEGIN
          TO_UPPER res_name
          SPRINT $all_resources("%res_name%") "set"
        END
      END
    END
  END
END

DEFINE_PATCH_FUNCTION ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_ITEM~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
  RET_ARRAY
    all_resources
BEGIN
  LPF ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_SPLITM~
    INT_VAR
      check_globals  = 1
      check_headers  = 1
      match_opcode   = %match_opcode%
      header_length = 0x38
    RET_ARRAY 
      all_resources
  END
END

DEFINE_PATCH_FUNCTION ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_SPELL~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
  RET_ARRAY
    all_resources
BEGIN
  LPF ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_SPLITM~
    INT_VAR
      check_globals  = 1
      check_headers  = 1
      match_opcode   = %match_opcode%
      header_length = 0x28
    RET_ARRAY
      all_resources
  END
END

DEFINE_ACTION_FUNCTION ~S!ADD_CLAB_ROW~
  STR_VAR
    filename = ~~
    row_desc = ~~
    level1   = ~****~
    level2   = ~****~
    level3   = ~****~
    level4   = ~****~
    level5   = ~****~
    level6   = ~****~
    level7   = ~****~
    level8   = ~****~
    level9   = ~****~
    level10  = ~****~
    level11  = ~****~
    level12  = ~****~
    level13  = ~****~
    level14  = ~****~
    level15  = ~****~
    level16  = ~****~
    level17  = ~****~
    level18  = ~****~
    level19  = ~****~
    level20  = ~****~
    level21  = ~****~
    level22  = ~****~
    level23  = ~****~
    level24  = ~****~
    level25  = ~****~
    level26  = ~****~
    level27  = ~****~
    level28  = ~****~
    level29  = ~****~
    level30  = ~****~
    level31  = ~****~
    level32  = ~****~
    level33  = ~****~
    level34  = ~****~
    level35  = ~****~
    level36  = ~****~
    level37  = ~****~
    level38  = ~****~
    level39  = ~****~
    level40  = ~****~
BEGIN
  COPY_EXISTING ~%filename%~ ~override~
    COUNT_2DA_COLS ~colcount~
    COUNT_2DA_ROWS ~colcount~ ~rowcount~
    PATCH_IF ~%row_desc%~ STR_EQ ~~ BEGIN
      new_row_value = %rowcount% + 1
      SPRINT row_description ~ABILITY%new_row_value%~
    END
    ELSE BEGIN
      SPRINT row_description ~%row_desc%~
    END
    INSERT_2DA_ROW ~rowcount~ ~colcount~ ~%row_description% %level1%  %level2%  %level3%  %level4%  %level5%  %level6%  %level7%  %level8%  %level9%  %level10%  %level11%  %level12%  %level13%  %level14%  %level15%  %level16%  %level17%  %level18%  %level19%  %level20%  %level21%  %level22%  %level23%  %level24%  %level25%  %level26%  %level27%  %level28%  %level29%  %level30%  %level31%  %level32%  %level33%  %level34%  %level35%  %level36%  %level37%  %level38%  %level39%  %level40%~
    PRETTY_PRINT_2DA
  BUT_ONLY
  IF_EXISTS
END

DEFINE_ACTION_FUNCTION ~S!ADD_HLA_ROW~
  STR_VAR
    filename           = ~~
    row_desc           = ~~
    ability            = ~*~
    icon               = ~*~
    strref             = ~*~
    min_level          = ~1~
    max_level          = ~99~
    num_allowed        = ~1~
    prerequisite       = ~*~
    excluded_by        = ~*~
    alignment_restrict = ~*~
BEGIN
  COPY_EXISTING ~%filename%~ ~override~
    COUNT_2DA_COLS ~colcount~
    COUNT_2DA_ROWS ~colcount~ ~rowcount~
    PATCH_IF ~%row_desc%~ STR_EQ ~~ BEGIN
      new_row_value = %rowcount% + 1
      SPRINT row_description ~%new_row_value%~
    END
    ELSE BEGIN
      SPRINT row_description ~%row_desc%~
    END
    INSERT_2DA_ROW ~rowcount~ ~colcount~ ~%row_description% %ability%  %icon%  %strref%  %min_level%  %max_level%  %num_allowed%  %prerequisite%  %excluded_by%  %alignment_restrict%~
    PRETTY_PRINT_2DA
  BUT_ONLY
  IF_EXISTS
END

DEFINE_ACTION_FUNCTION ~S!ADD_HLA_ROW~
  STR_VAR
    filename           = ~~
    row_desc           = ~~
    ability            = ~*~
    icon               = ~*~
    strref             = ~*~
    min_level          = ~1~
    max_level          = ~99~
    num_allowed        = ~1~
    prerequisite       = ~*~
    excluded_by        = ~*~
    alignment_restrict = ~*~
BEGIN
  COPY_EXISTING ~%filename%~ ~override~
    COUNT_2DA_COLS ~colcount~
    COUNT_2DA_ROWS ~colcount~ ~rowcount~
    SPRINT are_all_rows_filled ~TRUE~

    PATCH_IF ~%row_desc%~ STR_EQ ~~ BEGIN
      new_row_value = %rowcount% + 1
      SPRINT row_description ~%new_row_value%~
    END
    ELSE BEGIN
      SPRINT row_description ~%row_desc%~
    END
    READ_2DA_ENTRIES_NOW ~_read_%SOURCE_RES%~ ~colcount~
    FOR (current_row=0; current_row<%rowcount%; ++current_row) BEGIN
      READ_2DA_ENTRY_FORMER ~_read_%SOURCE_RES%~ %current_row% 1 ability_name
      PATCH_IF ~%ability_name%~ STR_EQ ~*~ BEGIN
        REMOVE_2DA_ROW current_row ~colcount~ // First unused row
        INSERT_2DA_ROW current_row ~colcount~ ~%row_description% %ability%  %icon%  %strref%  %min_level%  %max_level%  %num_allowed%  %prerequisite%  %excluded_by%  %alignment_restrict%~
        SET current_row = ~rowcount~
        SPRINT are_all_rows_filled ~FALSE~
      END
    END
    PATCH_IF are_all_rows_filled STR_EQ ~TRUE~ BEGIN
      INSERT_2DA_ROW ~rowcount~ ~colcount~ ~%row_description% %ability%  %icon%  %strref%  %min_level%  %max_level%  %num_allowed%  %prerequisite%  %excluded_by%  %alignment_restrict%~
    END
    PRETTY_PRINT_2DA
  BUT_ONLY
  IF_EXISTS
END

DEFINE_ACTION_FUNCTION ~S!ADD_PORTRAIT_ICON~
  INT_VAR
    description_str_ref = ~-1~
  STR_VAR
    bam_file = ~~
  RET
    portrait_icon_id
BEGIN
  COPY_EXISTING ~statdesc.2da~ ~override~
    COUNT_2DA_COLS ~colcount~
    COUNT_2DA_ROWS ~colcount~ ~rowcount~

    INSERT_2DA_ROW %rowcount% ~colcount~ ~%rowcount%         0         %bam_file%~
    SET_2DA_ENTRY %rowcount% 1 ~colcount~ ~%description_str_ref%~
    SET portrait_icon_id = %rowcount%
    PRETTY_PRINT_2DA
END

/// add a new spell state to splstate.ids ///
// https://www.gibberlings3.net/forums/topic/31421-how-to-get-hla-to-alter-other-abilities/
// thanks to Ardanis (supposedly), who's credited with the authorship of the function in the thread above
DEFINE_ACTION_FUNCTION resolve_state
  INT_VAR index=0 delete=0
  STR_VAR new_state_id = ~blah~
  RET new_state_index
BEGIN
  OUTER_SET min_new = 127

  COPY_EXISTING ~splstate.ids~ override
    new_state_index = 0
    found = 0

    READ_2DA_ENTRIES_NOW stats 2
    FOR (row=0; row<stats; row+=1) BEGIN
      READ_2DA_ENTRY_FORMER stats row 0 ind
      READ_2DA_ENTRY_FORMER stats row 1 str

      SET $stat("%row%") = ind

      PATCH_IF index BEGIN
        PATCH_IF ind = index BEGIN
          REMOVE_2DA_ROW row 2
          found = 1

          PATCH_IF delete = 0 BEGIN
            INSERT_2DA_ROW row 2 ~%index% %new_state_id%~
          END

          row = stats
        END
      END ELSE BEGIN
        PATCH_IF ~%str%~ STRING_EQUAL_CASE ~%new_state_id%~ BEGIN
          new_state_index = ind
          found = 1
          /* row=stats */ // don't stop looking, the same ID may be assigned to a greater index, which takes priority when compiling
        END
      END
    END

    PATCH_IF found = 0 BEGIN
      new_state_index = min_new

      PHP_EACH stat AS row => ind BEGIN
        PATCH_IF found = 0 && (row+1 < stats) BEGIN // not at the end of file
          next_row = row + 1
          next_ind = EVAL $stat("%next_row%")

          PATCH_IF index BEGIN
            PATCH_IF index<next_ind && index>ind BEGIN
              INSERT_2DA_ROW next_row 2 ~%index% %new_state_id%~
              found = 1
            END
          END ELSE BEGIN
            PATCH_IF new_state_index < next_ind BEGIN
              PATCH_IF ind < new_state_index BEGIN
                INSERT_2DA_ROW next_row 2 ~%new_state_index% %new_state_id%~
                found = 1
              END ELSE BEGIN
                new_state_index += 1

                PATCH_IF new_state_index < next_ind BEGIN
                  INSERT_2DA_ROW next_row 2 ~%new_state_index% %new_state_id%~
                  found = 1
                END
              END
            END
          END
        END ELSE BEGIN // at the end of file
          PATCH_IF found = 0 BEGIN
            PATCH_IF index BEGIN
              INSERT_2DA_ROW stats 2 ~%index% %new_state_id%~
            END ELSE BEGIN
              PATCH_IF new_state_index > ind BEGIN
                INSERT_2DA_ROW stats 2 ~%new_state_index% %new_state_id%~
              END ELSE BEGIN
                new_state_index += 1
                INSERT_2DA_ROW stats 2 ~%new_state_index% %new_state_id%~
              END
            END
          END
        END
      END
    END
END

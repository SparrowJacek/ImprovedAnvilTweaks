DEFINE_PATCH_FUNCTION ~S!ITMSPL_USES_OPCODE~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
    match_param2   = ~-999~ // param2, use -999 for all
    header_length = 0x38    // 0x38 for item, 0x28 for spell
  RET
    is_found
    opcode_resource
BEGIN
  SPRINT is_found "FALSE"
  SPRINT opcode_resource ""
  READ_LONG 0x6a fx_off
  PATCH_IF (check_globals = 1) BEGIN
    READ_SHORT 0x70 fx_num
    FOR (index = 0 ; index < fx_num ; ++index) BEGIN
      READ_SHORT (fx_off +        (index * 0x30)) opcode_file
      READ_ASCII (fx_off + 0x14 + (index * 0x30)) res_name
      PATCH_IF (match_opcode = opcode_file) BEGIN
        ///PATCH_PRINT ~File uses opcode %match_opcode% with res %res_name% in global effects~///
        SPRINT is_found "TRUE"
        SPRINT opcode_resource "%res_name%"
      END
    END
  END
  PATCH_IF (check_headers = 1) BEGIN
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    SET loop_start = 0
    SET loop_end = abil_num
    FOR (index2 = loop_start ; index2 < loop_end ; ++index2) BEGIN // looks through headers
      READ_BYTE (abil_off +        (index2 * header_length)) abil_type
      READ_SHORT (abil_off + 0x1e + (index2 * header_length)) abil_fx_num
      READ_SHORT (abil_off + 0x20 + (index2 * header_length)) abil_fx_idx
      FOR (index = 0 ; index < abil_fx_num ; index = index + 1) BEGIN
        READ_SHORT (fx_off +        ((abil_fx_idx + index) * 0x30)) opcode_file
        READ_LONG  (fx_off + 0x08 + ((abil_fx_idx + index) * 0x30)) param2
        READ_ASCII (fx_off + 0x14 + ((index + abil_fx_idx) * 0x30)) res_name
        PATCH_IF (match_opcode = opcode_file AND (match_param2 = ~-999~ OR match_param2 = param2)) BEGIN
          SPRINT is_found "TRUE"
          SPRINT opcode_resource "%res_name%"
          index=abil_fx_num
        END
      END
    END
  END
END

DEFINE_PATCH_FUNCTION ~S!SPELL_USES_OPCODE~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
    match_param2   = ~-999~ // param2, use -999 for all
  RET
    is_found
    opcode_resource
BEGIN
  LPF ~S!ITMSPL_USES_OPCODE~
    INT_VAR
      check_globals  = 1
      check_headers  = 1
      match_opcode   = %match_opcode%
      match_param2   = %match_param2%
      header_length = 0x28
    RET is_found opcode_resource
  END
END

DEFINE_PATCH_FUNCTION ~S!ITEM_USES_OPCODE~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
    match_param2   = ~-999~ // param2, use -999 for all
    header_length = 0x38    // 0x38 for item, 0x28 for spell
  RET
    is_found
    opcode_resource
BEGIN
  LPF ~S!ITMSPL_USES_OPCODE~
    INT_VAR
      check_globals  = 1
      check_headers  = 1
      match_opcode   = %match_opcode%
      match_param2   = %match_param2%
      header_length = 0x38
    RET is_found opcode_resource
  END
END

DEFINE_ACTION_FUNCTION ~S!ADD_SPLPROT_2DA_ENTRY~
  STR_VAR
    condition_description = ~~
    stat                  = ~~
    value                 = ~~
    relation              = ~~
  RET
    new_line_number
BEGIN
  COPY_EXISTING ~splprot.2da~ ~override/splprot.2da~
    COUNT_2DA_COLS ~colcount~
    COUNT_2DA_ROWS ~colcount~ ~rowcount~

    SPRINT new_line_number ~%rowcount%~
    INSERT_2DA_ROW ~rowcount~ ~colcount~ EVAL ~%condition_description% %stat% %value% %relation%~
    PRETTY_PRINT_2DA
  OUTER_SPRINT new_line_number ~%rowcount%~
END

DEFINE_PATCH_FUNCTION ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_SPLITM~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
    header_length = 0x38    // 0x38 for item, 0x28 for spell
  RET_ARRAY
    all_resources
BEGIN
  DEFINE_ASSOCIATIVE_ARRAY all_resources BEGIN
  END
  READ_LONG 0x6a fx_off
  PATCH_IF (check_globals = 1) BEGIN
    READ_SHORT 0x70 fx_num
    FOR (index = 0 ; index < fx_num ; ++index) BEGIN
      READ_SHORT (fx_off +        (index * 0x30)) opcode_file
      READ_ASCII (fx_off + 0x14 + (index * 0x30)) res_name
      PATCH_IF (match_opcode = opcode_file) AND NOT VARIABLE_IS_SET $all_resources("%res_name%") BEGIN
        SPRINT $all_resources("%res_name%") "set"
      END
    END
  END
  PATCH_IF (check_headers = 1) BEGIN
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    SET loop_start = 0
    SET loop_end = abil_num
    FOR (index2 = loop_start ; index2 < loop_end ; ++index2) BEGIN // looks through headers
      READ_BYTE (abil_off +        (index2 * header_length)) abil_type
      READ_SHORT (abil_off + 0x1e + (index2 * header_length)) abil_fx_num
      READ_SHORT (abil_off + 0x20 + (index2 * header_length)) abil_fx_idx
      FOR (index = 0 ; index < abil_fx_num ; index = index + 1) BEGIN
        READ_SHORT (fx_off +        ((abil_fx_idx + index) * 0x30)) opcode_file
        READ_ASCII (fx_off + 0x14 + ((index + abil_fx_idx) * 0x30)) res_name
        PATCH_IF (~%match_opcode%~ = ~%opcode_file%~) AND NOT VARIABLE_IS_SET $all_resources("%res_name%") BEGIN
          TO_UPPER res_name
          SPRINT $all_resources("%res_name%") "set"
        END
      END
    END
  END
END

DEFINE_PATCH_FUNCTION ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_ITEM~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
  RET_ARRAY
    all_resources
BEGIN
  LPF ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_SPLITM~
    INT_VAR
      check_globals  = 1
      check_headers  = 1
      match_opcode   = %match_opcode%
      header_length = 0x38
    RET_ARRAY 
      all_resources
  END
END

DEFINE_PATCH_FUNCTION ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_SPELL~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
  RET_ARRAY
    all_resources
BEGIN
  LPF ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_SPLITM~
    INT_VAR
      check_globals  = 1
      check_headers  = 1
      match_opcode   = %match_opcode%
      header_length = 0x28
    RET_ARRAY
      all_resources
  END
END

DEFINE_ACTION_FUNCTION ~S!ADD_CLAB_ROW~
  STR_VAR
    filename = ~~
    row_desc = ~~
    level1   = ~****~
    level2   = ~****~
    level3   = ~****~
    level4   = ~****~
    level5   = ~****~
    level6   = ~****~
    level7   = ~****~
    level8   = ~****~
    level9   = ~****~
    level10  = ~****~
    level11  = ~****~
    level12  = ~****~
    level13  = ~****~
    level14  = ~****~
    level15  = ~****~
    level16  = ~****~
    level17  = ~****~
    level18  = ~****~
    level19  = ~****~
    level20  = ~****~
    level21  = ~****~
    level22  = ~****~
    level23  = ~****~
    level24  = ~****~
    level25  = ~****~
    level26  = ~****~
    level27  = ~****~
    level28  = ~****~
    level29  = ~****~
    level30  = ~****~
    level31  = ~****~
    level32  = ~****~
    level33  = ~****~
    level34  = ~****~
    level35  = ~****~
    level36  = ~****~
    level37  = ~****~
    level38  = ~****~
    level39  = ~****~
    level40  = ~****~
BEGIN
  COPY_EXISTING ~%filename%~ ~override~
    COUNT_2DA_COLS ~colcount~
    COUNT_2DA_ROWS ~colcount~ ~rowcount~
    PATCH_IF ~%row_desc%~ STR_EQ ~~ BEGIN
      new_row_value = %rowcount% + 1
      SPRINT row_description ~ABILITY%new_row_value%~
    END
    ELSE BEGIN
      SPRINT row_description ~%row_desc%~
    END
    INSERT_2DA_ROW ~rowcount~ ~colcount~ ~%row_description% %level1%  %level2%  %level3%  %level4%  %level5%  %level6%  %level7%  %level8%  %level9%  %level10%  %level11%  %level12%  %level13%  %level14%  %level15%  %level16%  %level17%  %level18%  %level19%  %level20%  %level21%  %level22%  %level23%  %level24%  %level25%  %level26%  %level27%  %level28%  %level29%  %level30%  %level31%  %level32%  %level33%  %level34%  %level35%  %level36%  %level37%  %level38%  %level39%  %level40%~
    PRETTY_PRINT_2DA
  BUT_ONLY
  IF_EXISTS
END

// DEFINE_ACTION_FUNCTION ~S!ADD_HLA_ROW~
//   STR_VAR
//     filename           = ~~
//     row_desc           = ~~
//     ability            = ~*~
//     icon               = ~*~
//     strref             = ~*~
//     min_level          = ~1~
//     max_level          = ~99~
//     num_allowed        = ~1~
//     prerequisite       = ~*~
//     excluded_by        = ~*~
//     alignment_restrict = ~*~
// BEGIN
//   COPY_EXISTING ~%filename%~ ~override~
//     COUNT_2DA_COLS ~colcount~
//     COUNT_2DA_ROWS ~colcount~ ~rowcount~
//     PATCH_IF ~%row_desc%~ STR_EQ ~~ BEGIN
//       new_row_value = %rowcount% + 1
//       SPRINT row_description ~%new_row_value%~
//     END
//     ELSE BEGIN
//       SPRINT row_description ~%row_desc%~
//     END
//     INSERT_2DA_ROW ~rowcount~ ~colcount~ ~%row_description% %ability%  %icon%  %strref%  %min_level%  %max_level%  %num_allowed%  %prerequisite%  %excluded_by%  %alignment_restrict%~
//     PRETTY_PRINT_2DA
//   BUT_ONLY
//   IF_EXISTS
// END

DEFINE_ACTION_FUNCTION ~S!ADD_HLA_ROW~
  STR_VAR
    filename           = ~~
    row_desc           = ~~
    ability            = ~*~
    icon               = ~*~
    strref             = ~*~
    min_level          = ~1~
    max_level          = ~99~
    num_allowed        = ~1~
    prerequisite       = ~*~
    excluded_by        = ~*~
    alignment_restrict = ~*~
BEGIN
  COPY_EXISTING ~%filename%~ ~override~
    COUNT_2DA_COLS ~colcount~
    COUNT_2DA_ROWS ~colcount~ ~rowcount~
    SPRINT are_all_rows_filled ~TRUE~

    PATCH_IF ~%row_desc%~ STR_EQ ~~ BEGIN
      new_row_value = %rowcount% + 1
      SPRINT row_description ~%new_row_value%~
    END
    ELSE BEGIN
      SPRINT row_description ~%row_desc%~
    END
    READ_2DA_ENTRIES_NOW ~_read_%SOURCE_RES%~ ~colcount~
    FOR (current_row=0; current_row<%rowcount%; ++current_row) BEGIN
      READ_2DA_ENTRY_FORMER ~_read_%SOURCE_RES%~ %current_row% 1 ability_name
      PATCH_IF ~%ability_name%~ STR_EQ ~*~ BEGIN
        REMOVE_2DA_ROW current_row ~colcount~ // First unused row
        INSERT_2DA_ROW current_row ~colcount~ ~%row_description% %ability%  %icon%  %strref%  %min_level%  %max_level%  %num_allowed%  %prerequisite%  %excluded_by%  %alignment_restrict%~
        SET current_row = ~rowcount~
        SPRINT are_all_rows_filled ~FALSE~
      END
    END
    PATCH_IF are_all_rows_filled STR_EQ ~TRUE~ BEGIN
      INSERT_2DA_ROW ~rowcount~ ~colcount~ ~%row_description% %ability%  %icon%  %strref%  %min_level%  %max_level%  %num_allowed%  %prerequisite%  %excluded_by%  %alignment_restrict%~
    END
    PRETTY_PRINT_2DA
  BUT_ONLY
  IF_EXISTS
END

DEFINE_ACTION_FUNCTION ~S!ADD_PORTRAIT_ICON~
  INT_VAR
    description_str_ref = ~-1~
  STR_VAR
    bam_file = ~~
  RET
    portrait_icon_id
BEGIN
  COPY_EXISTING ~statdesc.2da~ ~override~
    COUNT_2DA_COLS ~colcount~
    COUNT_2DA_ROWS ~colcount~ ~rowcount~

    INSERT_2DA_ROW %rowcount% ~colcount~ ~%rowcount%         0         %bam_file%~
    SET_2DA_ENTRY %rowcount% 1 ~colcount~ ~%description_str_ref%~
    SET portrait_icon_id = %rowcount%
    PRETTY_PRINT_2DA
END

/// add a new spell state to splstate.ids ///
// https://www.gibberlings3.net/forums/topic/31421-how-to-get-hla-to-alter-other-abilities/
// thanks to Ardanis (supposedly), who's credited with the authorship of the function in the thread above
DEFINE_ACTION_FUNCTION resolve_state
  INT_VAR index=0 delete=0
  STR_VAR new_state_id = ~blah~
  RET new_state_index
BEGIN
  OUTER_SET min_new = 127

  COPY_EXISTING ~splstate.ids~ override
    new_state_index = 0
    found = 0

    READ_2DA_ENTRIES_NOW stats 2
    FOR (row=0; row<stats; row+=1) BEGIN
      READ_2DA_ENTRY_FORMER stats row 0 ind
      READ_2DA_ENTRY_FORMER stats row 1 str

      SET $stat("%row%") = ind

      PATCH_IF index BEGIN
        PATCH_IF ind = index BEGIN
          REMOVE_2DA_ROW row 2
          found = 1

          PATCH_IF delete = 0 BEGIN
            INSERT_2DA_ROW row 2 ~%index% %new_state_id%~
          END

          row = stats
        END
      END ELSE BEGIN
        PATCH_IF ~%str%~ STRING_EQUAL_CASE ~%new_state_id%~ BEGIN
          new_state_index = ind
          found = 1
          /* row=stats */ // don't stop looking, the same ID may be assigned to a greater index, which takes priority when compiling
        END
      END
    END

    PATCH_IF found = 0 BEGIN
      new_state_index = min_new

      PHP_EACH stat AS row => ind BEGIN
        PATCH_IF found = 0 && (row+1 < stats) BEGIN // not at the end of file
          next_row = row + 1
          next_ind = EVAL $stat("%next_row%")

          PATCH_IF index BEGIN
            PATCH_IF index<next_ind && index>ind BEGIN
              INSERT_2DA_ROW next_row 2 ~%index% %new_state_id%~
              found = 1
            END
          END ELSE BEGIN
            PATCH_IF new_state_index < next_ind BEGIN
              PATCH_IF ind < new_state_index BEGIN
                INSERT_2DA_ROW next_row 2 ~%new_state_index% %new_state_id%~
                found = 1
              END ELSE BEGIN
                new_state_index += 1

                PATCH_IF new_state_index < next_ind BEGIN
                  INSERT_2DA_ROW next_row 2 ~%new_state_index% %new_state_id%~
                  found = 1
                END
              END
            END
          END
        END ELSE BEGIN // at the end of file
          PATCH_IF found = 0 BEGIN
            PATCH_IF index BEGIN
              INSERT_2DA_ROW stats 2 ~%index% %new_state_id%~
            END ELSE BEGIN
              PATCH_IF new_state_index > ind BEGIN
                INSERT_2DA_ROW stats 2 ~%new_state_index% %new_state_id%~
              END ELSE BEGIN
                new_state_index += 1
                INSERT_2DA_ROW stats 2 ~%new_state_index% %new_state_id%~
              END
            END
          END
        END
      END
    END
END

// Copied from CamDawg's ALTER_EFFECT available here https://github.com/WeiDUorg/weidu/blob/devel/src/tph/include/cd_functions.tpa
// This version allows for matching and setting negative values for parameter1 and 2
DEFINE_PATCH_FUNCTION ~S!ALTER_EFFECT~

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0
          silent              = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-999"
          match_parameter2    = "-999"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-999"
          match_special       = "-999"

  // variables for the new effect
          opcode              = "-1"
          target              = "-1"
          power               = "-1"
          parameter1          = "-999"
          parameter2          = "-999"
          timing              = "-1"
          resist_dispel       = "-1"
          duration            = "-1"
          duration_high       = "-1"
          probability1        = "-1"
          probability2        = "-1"
          dicenumber          = "-1"
          dicesize            = "-1"
          savingthrow         = "-1"
          savebonus           = "-999"
          special             = "-999"

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
          resource            = "SAME"

BEGIN  

  // set variables and offsets based on the file type
  SET alter = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  READ_ASCII 0x04 version (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.0" = 0) BEGIN // iwd2, spl 2.0
        SET min_size       = 0x82
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      PATCH_IF (check_headers = 0) BEGIN
        SET abil_num = 0
      END ELSE BEGIN
        READ_LONG   0x64 abil_off ELSE 0
        READ_SHORT  0x68 abil_num ELSE 0
      END
    END

    "ITM "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.1" = 0) BEGIN // pst, itm v1.1
        SET min_size       = 0x9a
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      PATCH_IF (check_headers = 0) BEGIN
        SET abil_num = 0
      END ELSE BEGIN
        READ_LONG   0x64 abil_off ELSE 0
        READ_SHORT  0x68 abil_num ELSE 0
      END
    END

    "CRE "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
        SET min_size       = 0x378
        READ_LONG  0x368 fx_off ELSE 0
        SET counter_offset = 0x36c
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
        SET min_size       = 0x62e
        READ_LONG  0x61e fx_off ELSE 0
        SET counter_offset = 0x622
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
        SET min_size       = 0x33c
        READ_LONG  0x32c fx_off ELSE 0
        SET counter_offset = 0x330
      END ELSE BEGIN                                               // everything else, cre v1.0
        SET min_size = 0x2d4
        READ_LONG  0x2c4 fx_off ELSE 0
        SET counter_offset = 0x2c8
      END
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      SET abil_length = 0
      SET check_globals = 1
      READ_BYTE 0x33 fx_type ELSE 2
    END

    "fail"
    BEGIN
      PATCH_WARN "WARNING: ALTER_EFFECT does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_WARN "WARNING: ALTER_EFFECT does not support file type %sig%"
  END

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_BYTE   (abil_off +        (abil_length * index)) abil_type
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0))) BEGIN                               // and only on the right # header, if specified
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < counter ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          // match ALL these variables, if specified
          PATCH_IF (((match_opcode        = o_opcode)        OR (match_opcode < 0))        AND
                    ((match_target        = o_target)        OR (match_target < 0))        AND
                    ((match_power         = o_power)         OR (match_power < 0))         AND
                    ((match_parameter1    = o_parameter1)    OR (match_parameter1 = ~-999~))    AND
                    ((match_parameter2    = o_parameter2)    OR (match_parameter2 = ~-999~))    AND
                    ((match_timing        = o_timing)        OR (match_timing < 0))        AND
                    ((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0)) AND
                    ((match_duration      = o_duration)      OR (match_duration < 0))      AND
                    ((match_probability1  = o_probability1)  OR (match_probability1 < 0))  AND
                    ((match_probability2  = o_probability2)  OR (match_probability2 < 0))  AND
                    ((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))    AND
                    ((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))      AND
                    ((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))   AND
                    ((match_savebonus     = o_savebonus)     OR (match_savebonus = ~-999~)) AND
                    ((match_special       = o_special)       OR (match_special = ~-999~))       AND
                    (("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0))) BEGIN

            // lazily re-use code
            SET base = (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type))))

            // overwrite the cloned effect with the new variables, if specified
            PATCH_IF (opcode >= 0)        BEGIN WRITE_SHORT (base        + (0x08 * fx_type)) opcode        END
            PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (base + 0x02 + (0x0a * fx_type)) target        END
            PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (base + 0x03 + (0x0d * fx_type)) power         END
            PATCH_IF (parameter1 > ~-999~)    BEGIN WRITE_LONG  (base + 0x04 + (0x10 * fx_type)) parameter1    END
            PATCH_IF (parameter2 > ~-999~)    BEGIN WRITE_LONG  (base + 0x08 + (0x10 * fx_type)) parameter2    END
            PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (base + 0x0c + (0x10 * fx_type)) timing        END
            PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (base + 0x0d + (0x47 * fx_type)) resist_dispel END
            PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (base + 0x0e + (0x12 * fx_type)) duration      END
            PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (base + 0x12 + (0x12 * fx_type)) probability1  END
            PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (base + 0x13 + (0x13 * fx_type)) probability2  END
            PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (base + 0x1c + (0x14 * fx_type)) dicenumber    END
            PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (base + 0x20 + (0x14 * fx_type)) dicesize      END
            PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (base + 0x24 + (0x14 * fx_type)) savingthrow   END
            PATCH_IF (savebonus > ~-999~) BEGIN WRITE_LONG  (base + 0x28 + (0x14 * fx_type)) savebonus     END
            PATCH_IF (special > ~-999~)       BEGIN WRITE_LONG  (base + 0x2c + (0x14 * fx_type)) special       END
            PATCH_IF ("%resource%" STRING_COMPARE_CASE "SAME" != 0) BEGIN
              WRITE_ASCIIE (base + 0x14 + (0x14 * fx_type)) "%resource%" #8
            END

            // update the tracking vars
            SET alter += 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers
    END // end loop through effects on ability
  END // end ability loop

  PATCH_IF (alter = 0 && !silent) BEGIN
    PATCH_WARN "WARNING: no effects altered on %SOURCE_FILE%"
  END

  PATCH_IF (verbose && !silent) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %alter% effect(s) altered"
  END

END

// ADD_SPELL_HEADER: add spell header to item.                                         //
// This is a PATCH function. All integer variables default to 0.                        //
// The string variable icon defaults to the string "".                                  //

DEFINE_PATCH_FUNCTION ~S!ADD_SPELL_HEADER~
INT_VAR
  header_type        = "0" // 0 by default, otherwise use value here
  friendly           = "0" // ‘Friendly’ ability (PST only) at 0x01
  location           = "0" // ability location at 0x02
  target             = "0" // target at 0x0c
  target_count       = "0" // target_count at 0x0d
  range              = "0" // range at 0x0e
  level_req          = "0" // level required at 0x10
  cast_time          = "0" // casting time at 0x12
  casts_per_day      = "0" // casts per day 0x14
//dicesize           = "0" // dice size (unused) at 0x16
//dicenumber         = "0" // number of dice (unused) at 0x18
//enchanted          = "0" // enchanted (unused) at 0x1a
//damage_type        = "0" // damage type (unused) at 0x1c
//effects_num        = "0" // number of effects at 0x1e
//effects_index      = "0" // effects index at 0x20
//charges            = "0" // number of charges (unused) at 0x22
//drained            = "0" // when drained? (unused) at 0x24
  projectile         = "0" // projectile at 0x26
STR_VAR
  icon               = ""  // ability icon at 0x04
BEGIN
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  READ_LONG  0x6a fx_off
  READ_SHORT 0x70 fx_num

  // calculate the new effect indice
  FOR (i = 0; i < "%abil_num%"; i += 1) BEGIN
    READ_SHORT (%abil_off% + %i% * 0x28 + 0x1e) abil_fx_cnt
    SET %fx_num% += abil_fx_cnt
  END

  // add ability
  INSERT_BYTES (%abil_off% + %abil_num% * 0x28)  0x28

  // write stuff
  WRITE_BYTE   (%abil_off% + %abil_num% * 0x28        )   header_type        // Attack Type
  WRITE_BYTE   (%abil_off% + %abil_num% * 0x28 + 0x001)   friendly           // ‘Friendly’ (PST only)
  WRITE_SHORT  (%abil_off% + %abil_num% * 0x28 + 0x002)   location           // Location
  WRITE_ASCIIE (%abil_off% + %abil_num% * 0x28 + 0x004)   "%icon%" #8        // Icon
  WRITE_BYTE   (%abil_off% + %abil_num% * 0x28 + 0x00c)   target             // Target type
  WRITE_BYTE   (%abil_off% + %abil_num% * 0x28 + 0x00d)   target_count       // Target count
  WRITE_SHORT  (%abil_off% + %abil_num% * 0x28 + 0x00e)   range              // Range
  WRITE_SHORT  (%abil_off% + %abil_num% * 0x28 + 0x010)   level_req          // Level required
  WRITE_SHORT  (%abil_off% + %abil_num% * 0x28 + 0x012)   cast_time          // Cast_time
  WRITE_SHORT  (%abil_off% + %abil_num% * 0x28 + 0x014)   casts_per_day      // Casts per day
  WRITE_SHORT  (%abil_off% + %abil_num% * 0x28 + 0x016)   0                  // Dice sides (unused)
  WRITE_SHORT  (%abil_off% + %abil_num% * 0x28 + 0x018)   0                  // Dice thrown (unused)
  WRITE_SHORT  (%abil_off% + %abil_num% * 0x28 + 0x01a)   0                  // Enchanted (unused)
  WRITE_SHORT  (%abil_off% + %abil_num% * 0x28 + 0x01c)   0                  // Damage type (unused)
  WRITE_SHORT  (%abil_off% + %abil_num% * 0x28 + 0x01e)   0                  // Count of feature blocks
  WRITE_SHORT  (%abil_off% + %abil_num% * 0x28 + 0x020)   %fx_num%           // Offset to feature blocks
  WRITE_SHORT  (%abil_off% + %abil_num% * 0x28 + 0x022)   0                  // Charges (unused)
  WRITE_SHORT  (%abil_off% + %abil_num% * 0x28 + 0x024)   0                  // Charge depletion behaviour (unused)
  WRITE_SHORT  (%abil_off% + %abil_num% * 0x28 + 0x026)   projectile         // Projectile animation (projectl.ids/missile.ids)

  // update ability count and starting fx offset
  SET %abil_num% += 1
  SET %fx_off% += 0x28

  WRITE_SHORT 0x68 %abil_num%
  WRITE_LONG  0x6a %fx_off%
END

DEFINE_PATCH_FUNCTION ~S!CLONE_SPELL_HEADER~
INT_VAR
  header_to_copy = 0
  level_req = 1
  
BEGIN
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  READ_LONG  0x6a fx_off
  READ_SHORT 0x70 fx_num

  // calculate offset to header which should be copied
  SET %original_header_offset% = %abil_off% + %header_to_copy% * 0x28

  // read contents of original header
  READ_BYTE   (%original_header_offset%        )   header_type        // Attack Type
  READ_BYTE   (%original_header_offset% + 0x001)   friendly           // ‘Friendly’ (PST only)
  READ_SHORT  (%original_header_offset% + 0x002)   location           // Location
  READ_ASCII  (%original_header_offset% + 0x004)   icon (8)           // Icon
  READ_BYTE   (%original_header_offset% + 0x00c)   target             // Target type
  READ_BYTE   (%original_header_offset% + 0x00d)   target_count       // Target count
  READ_SHORT  (%original_header_offset% + 0x00e)   range              // Range
  READ_SHORT  (%original_header_offset% + 0x012)   cast_time          // cast_time
  READ_SHORT  (%original_header_offset% + 0x014)   casts_per_day      // THAC0 bonus
  READ_SHORT  (%original_header_offset% + 0x01e)   num_effs           // Count of feature blocks
  READ_SHORT  (%original_header_offset% + 0x020)   first_eff          // Offset to feature blocks
  READ_SHORT  (%original_header_offset% + 0x026)   projectile         // Projectile animation (projectl.ids/missile.ids)

  LAUNCH_PATCH_FUNCTION ~S!ADD_SPELL_HEADER~
    INT_VAR
      header_type        = %header_type% // 0 by default, otherwise use value here
      friendly           = %friendly% // ‘Friendly’ ability (PST only) at 0x01
      location           = %location% // ability location at 0x02
      target             = %target% // target at 0x0c
      target_count       = %target_count% // target_count at 0x0d
      range              = %range% // range at 0x0e
      level_req          = %level_req% // level required at 0x10
      cast_time          = %cast_time% // casting time at 0x12
      casts_per_day      = %casts_per_day% // casts per day 0x14
      projectile         = %projectile% // projectile at 0x26
    STR_VAR
      icon               = EVALUATE_BUFFER "%icon%"  // ability icon at 0x04
  END
    //Clones all effects
  FOR (i = 0; i < %num_effs%; i += 1) BEGIN
	SET %effect_offset% = %fx_off% + 0x30 * (%first_eff% + %i%) + 0x28
    READ_SHORT  (       %effect_offset%) opcode
    READ_BYTE   (0x02 + %effect_offset%) target
    READ_BYTE   (0x03 + %effect_offset%) power
    READ_LONG   (0x04 + %effect_offset%) parameter1
    READ_LONG   (0x08 + %effect_offset%) parameter2
    READ_BYTE   (0x0c + %effect_offset%) timing
    READ_BYTE   (0x0d + %effect_offset%) resist_dispel
    READ_LONG   (0x0e + %effect_offset%) duration
    READ_BYTE   (0x12 + %effect_offset%) probability1
    READ_BYTE   (0x13 + %effect_offset%) probability2
    READ_ASCII  (0x14 + %effect_offset%) resource (8)
    READ_LONG   (0x1c + %effect_offset%) dicenumber
    READ_LONG   (0x20 + %effect_offset%) dicesize
    READ_LONG   (0x24 + %effect_offset%) savingthrow
    READ_LONG   (0x28 + %effect_offset%) savebonus
	LAUNCH_PATCH_FUNCTION ~ADD_SPELL_EFFECT~
      INT_VAR
        opcode              = %opcode%
        target              = %target%
        power               = %power%
        parameter1          = %parameter1%
        parameter2          = %parameter2%
        timing              = %timing%
        resist_dispel       = %resist_dispel%
        duration            = %duration%
        probability1        = %probability1%
        probability2        = %probability2%
        dicenumber          = %dicenumber%
        dicesize            = %dicesize%
        savingthrow         = %savingthrow%
        savebonus           = %savebonus%
		header              = %abil_num% + 1
      STR_VAR
        resource            = EVALUATE_BUFFER "%resource%"
    END
  END
END


DEFINE_ACTION_FUNCTION ~S!ADD_7EYES_ROW~
  INT_VAR
    strref        = ~*~
  STR_VAR
    row_desc      = ~*~
    spellstate    = ~*~
    eff1          = ~*~
    eff2          = ~*~
    eff3          = ~*~
    eff4          = ~*~
    eff5          = ~*~
    eff6          = ~*~
    eff7          = ~*~
    eff8          = ~*~
    eff9          = ~*~
  RET
    new_row_id
BEGIN
  COPY_EXISTING ~7eyes.2da~ ~override~
    COUNT_2DA_COLS ~colcount~
    COUNT_2DA_ROWS ~colcount~ ~rowcount~
    // SPRINT are_all_rows_filled ~TRUE~
    SPRINT new_row_id EVAL ~%rowcount%~

    PATCH_IF ~%row_desc%~ STR_EQ ~~ BEGIN
      new_row_value = %rowcount% + 1
      SPRINT row_description ~%new_row_value%~
    END
    ELSE BEGIN
      SPRINT row_description ~%row_desc%~
    END
    // READ_2DA_ENTRIES_NOW ~_read_%SOURCE_RES%~ ~colcount~
    // FOR (current_row=0; current_row<%rowcount%; ++current_row) BEGIN
    //   READ_2DA_ENTRY_FORMER ~_read_%SOURCE_RES%~ %current_row% 1 ability_name
    //   PATCH_IF ~%ability_name%~ STR_EQ ~****~ BEGIN
    //     REMOVE_2DA_ROW current_row ~colcount~ // First unused row
    //     INSERT_2DA_ROW current_row ~colcount~ ~%row_desc% %spellstate% %strref% %eff1% %eff2% %eff3% %eff4% %eff5% %eff6% %eff7% %eff8% %eff9% ~
    //     SET current_row = ~rowcount~
    //     SPRINT are_all_rows_filled ~FALSE~
    //   END
    // END
    // PATCH_IF are_all_rows_filled STR_EQ ~TRUE~ BEGIN
    INSERT_2DA_ROW ~rowcount~ ~colcount~ ~%row_desc% %spellstate% %strref% %eff1% %eff2% %eff3% %eff4% %eff5% %eff6% %eff7% %eff8% %eff9% ~
    // END
    PRETTY_PRINT_2DA
END

// Copied from CamDawg's CLONE_EFFECT available here https://github.com/WeiDUorg/weidu/blob/devel/src/tph/include/cd_functions.tpa
// This version allows for matching and setting negative values for parameter1 and 2
DEFINE_PATCH_FUNCTION ~S!CLONE_EFFECT~

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0
          silent              = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-999"
          match_parameter2    = "-999"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-999"
          match_special       = "-999"

  // variables for the new effect
          opcode              = "-1"
          target              = "-1"
          power               = "-1"
          parameter1          = "-999"
          parameter2          = "-999"
          timing              = "-1"
          resist_dispel       = "-1"
          duration            = "-1"
          duration_high       = "-1"
          probability1        = "-1"
          probability2        = "-1"
          dicenumber          = "-1"
          dicesize            = "-1"
          savingthrow         = "-1"
          savebonus           = "-999"
          special             = "-999"

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
          resource            = "SAME"
          insert              = "above"

BEGIN
  PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.1" = 0) BEGIN // iwd2, are v9.1
    READ_LONG  0x78 ent_off
    READ_LONG  0x7c ent_num
  END ELSE BEGIN
    READ_LONG  0x68 ent_off
    READ_LONG  0x6c ent_num
  END

  // set variables and offsets based on the file type
  SET new_fx = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  READ_ASCII 0x04 version (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.0" = 0) BEGIN // iwd2, spl 2.0
        SET min_size       = 0x82
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "ITM "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.1" = 0) BEGIN // pst, itm v1.1
        SET min_size       = 0x9a
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "CRE "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
        SET min_size       = 0x378
        READ_LONG  0x368 fx_off
        SET counter_offset = 0x36c
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
        SET min_size       = 0x62e
        READ_LONG  0x61e fx_off
        SET counter_offset = 0x622
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
        SET min_size       = 0x33c
        READ_LONG  0x32c fx_off
        SET counter_offset = 0x330
      END ELSE BEGIN                                               // everything else, cre v1.0
        SET min_size = 0x2d4
        READ_LONG  0x2c4 fx_off
        SET counter_offset = 0x2c8
      END
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      SET abil_length = 0
      SET check_globals = 1
      READ_BYTE 0x33 fx_type ELSE 2
    END

    "fail"
    BEGIN
      PATCH_FAIL "ERROR: CLONE_EFFECT does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_FAIL "ERROR: CLONE_EFFECT does not support file type %sig%"
  END

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_BYTE   (abil_off +        (abil_length * index)) abil_type
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        WRITE_SHORT (abil_off + 0x20 + (abil_length * index)) (THIS + new_fx) // update index with previously added effects
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0)) AND                                  // and only on the right # header, if specified
                ((index < 0) OR (check_headers))) BEGIN                                 // if check headers = 0, only re-index
        SET last = 0                              // and only on the right # header, if specified
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < (counter - last) ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          // match ALL these variables, if specified
          PATCH_IF (((match_opcode        = o_opcode)        OR (match_opcode < 0))        AND
                    ((match_target        = o_target)        OR (match_target < 0))        AND
                    ((match_power         = o_power)         OR (match_power < 0))         AND
                    ((match_parameter1    = o_parameter1)    OR (match_parameter1 = ~-999~))    AND
                    ((match_parameter2    = o_parameter2)    OR (match_parameter2 = ~-999~))    AND
                    ((match_timing        = o_timing)        OR (match_timing < 0))        AND
                    ((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0)) AND
                    ((match_duration      = o_duration)      OR (match_duration < 0))      AND
                    ((match_probability1  = o_probability1)  OR (match_probability1 < 0))  AND
                    ((match_probability2  = o_probability2)  OR (match_probability2 < 0))  AND
                    ((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))    AND
                    ((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))      AND
                    ((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))   AND
                    ((match_savebonus     = o_savebonus)     OR (match_savebonus = ~-999~)) AND
                    ((match_special       = o_special)       OR (match_special = ~-999~))       AND
                    (("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0)))
          BEGIN

            // now that we've got a match, read-and-clone it:
            READ_ASCII   (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) clone (0x30 + (0xd8 * fx_type))
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "below" = 0) BEGIN
              SET base = (fx_off        + ((abil_fx_idx + index2 + 1) * (0x30 + (0xd8 * fx_type))))
            END ELSE
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "first" = 0) BEGIN
              SET base = (fx_off        + (abil_fx_idx * (0x30 + (0xd8 * fx_type))))
            END ELSE
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "last" = 0) BEGIN
              SET base = (fx_off        + ((abil_fx_idx + counter) * (0x30 + (0xd8 * fx_type))))
            END ELSE BEGIN
              SET base = (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type))))
            END
            INSERT_BYTES base (0x30 + (0xd8 * fx_type))
            WRITE_ASCIIE base "%clone%"

            // overwrite the cloned effect with the new variables, if specified
            PATCH_IF (opcode >= 0)        BEGIN WRITE_SHORT (base        + (0x08 * fx_type)) opcode        END
            PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (base + 0x02 + (0x0a * fx_type)) target        END
            PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (base + 0x03 + (0x0d * fx_type)) power         END
            PATCH_IF (parameter1 > ~-999~)    BEGIN WRITE_LONG  (base + 0x04 + (0x10 * fx_type)) parameter1    END
            PATCH_IF (parameter2 > ~-999~)    BEGIN WRITE_LONG  (base + 0x08 + (0x10 * fx_type)) parameter2    END
            PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (base + 0x0c + (0x10 * fx_type)) timing        END
            PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (base + 0x0d + (0x47 * fx_type)) resist_dispel END
            PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (base + 0x0e + (0x12 * fx_type)) duration      END
            PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (base + 0x12 + (0x12 * fx_type)) probability1  END
            PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (base + 0x13 + (0x13 * fx_type)) probability2  END
            PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (base + 0x1c + (0x14 * fx_type)) dicenumber    END
            PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (base + 0x20 + (0x14 * fx_type)) dicesize      END
            PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (base + 0x24 + (0x14 * fx_type)) savingthrow   END
            PATCH_IF (savebonus > ~-999~) BEGIN WRITE_LONG  (base + 0x28 + (0x14 * fx_type)) savebonus     END
            PATCH_IF (special > ~-999~)       BEGIN WRITE_LONG  (base + 0x2c + (0x14 * fx_type)) special       END
            PATCH_IF ("%resource%" STRING_COMPARE_CASE "SAME" != 0) BEGIN
              WRITE_ASCIIE (base + 0x14 + (0x14 * fx_type)) "%resource%" #8
            END

            // update the tracking vars
            SET new_fx += 1
            SET counter += 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
              PATCH_IF ("%insert%" STRING_COMPARE_CASE "last" = 0) BEGIN
                SET last += 1
              END ELSE BEGIN
                SET index2 += 1
              END
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers
      WRITE_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
    END // end loop through effects on ability
  END // end ability loop

  // now adjust offsets for creature files
  PATCH_IF (("%sig%" STRING_EQUAL "CRE ") AND (new_fx > 0)) BEGIN // fix offsets for cre files if fx inserted
    SET inserted = ((0x30 + (0xd8 * fx_type)) * new_fx)
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
      PATCH_FOR_EACH offset IN 0x294 0x344 0x34c 0x354 0x35c 0x360 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
      PATCH_FOR_EACH offset IN 0x5fa 0x602 0x60a 0x612 0x616 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
      FOR (offset = 0x3ba ; offset < 0x4b3 ; offset = offset + 0x04) BEGIN // all of the spell offsets
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
      FOR (offset = 0x5b2 ; offset < 0x5d3 ; offset = offset + 0x04) BEGIN // domain spell offsets
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
      PATCH_FOR_EACH offset IN 0x308 0x310 0x318 0x320 0x324 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE BEGIN                                               // everything else, cre v1.0
      PATCH_FOR_EACH offset IN 0x2a0 0x2a8 0x2b0 0x2b8 0x2bc BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END
  END

  PATCH_IF (new_fx = 0 && !silent) BEGIN
    PATCH_WARN "WARNING: no effects added to %SOURCE_FILE%"
  END ELSE PATCH_IF (verbose && !silent) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %new_fx% effect(s) added"
  END

END

DEFINE_PATCH_FUNCTION ~S!ITMSPL_USES_OPCODE~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
    header_length = 0x38    // 0x38 for item, 0x28 for spell
  RET
    is_found
    opcode_resource
BEGIN
  SPRINT is_found "FALSE"
  SPRINT opcode_resource ""
  READ_LONG 0x6a fx_off
  PATCH_IF (check_globals = 1) BEGIN
    READ_SHORT 0x70 fx_num
    FOR (index = 0 ; index < fx_num ; ++index) BEGIN
      READ_SHORT (fx_off +        (index * 0x30)) opcode_file
      READ_ASCII (fx_off + 0x14 + (index * 0x30)) res_name
      PATCH_IF (match_opcode = opcode_file) BEGIN
        ///PATCH_PRINT ~File uses opcode %match_opcode% with res %res_name% in global effects~///
        SPRINT is_found "TRUE"
        SPRINT opcode_resource "%res_name%"
      END
    END
  END
  PATCH_IF (check_headers = 1) BEGIN
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    SET loop_start = 0
    SET loop_end = abil_num
    FOR (index2 = loop_start ; index2 < loop_end ; ++index2) BEGIN // looks through headers
      READ_BYTE (abil_off +        (index2 * header_length)) abil_type
      READ_SHORT (abil_off + 0x1e + (index2 * header_length)) abil_fx_num
      READ_SHORT (abil_off + 0x20 + (index2 * header_length)) abil_fx_idx
      FOR (index = 0 ; index < abil_fx_num ; index = index + 1) BEGIN
        READ_SHORT (fx_off +        ((abil_fx_idx + index) * 0x30)) opcode_file
        READ_ASCII (fx_off + 0x14 + ((index + abil_fx_idx) * 0x30)) res_name
        PATCH_IF (match_opcode = opcode_file) BEGIN
          SPRINT is_found "TRUE"
          SPRINT opcode_resource "%res_name%"
          index=abil_fx_num
        END
      END
    END
  END
END

DEFINE_PATCH_FUNCTION ~S!SPELL_USES_OPCODE~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
  RET
    is_found
    opcode_resource
BEGIN
  LPF ~S!ITMSPL_USES_OPCODE~
    INT_VAR
      check_globals  = 1
      check_headers  = 1
      match_opcode   = %match_opcode%
      header_length = 0x28
    RET is_found opcode_resource
  END
END

DEFINE_PATCH_FUNCTION ~S!ITEM_USES_OPCODE~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
    header_length = 0x38    // 0x38 for item, 0x28 for spell
  RET
    is_found
    opcode_resource
BEGIN
  LPF ~S!ITMSPL_USES_OPCODE~
    INT_VAR
      check_globals  = 1
      check_headers  = 1
      match_opcode   = %match_opcode%
      header_length = 0x38
    RET is_found opcode_resource
  END
END

DEFINE_ACTION_FUNCTION ~S!ADD_SPLPROT_2DA_ENTRY~
  STR_VAR
    condition_description = ~~
    stat                  = ~~
    value                 = ~~
    relation              = ~~
  RET
    new_line_number
BEGIN
  COPY_EXISTING ~splprot.2da~ ~override/splprot.2da~
    COUNT_2DA_COLS ~colcount~
    COUNT_2DA_ROWS ~colcount~ ~rowcount~

    SPRINT new_line_number ~%rowcount%~
    INSERT_2DA_ROW ~rowcount~ ~colcount~ EVAL ~%condition_description% %stat% %value% %relation%~
    PRETTY_PRINT_2DA
  OUTER_SPRINT new_line_number ~%rowcount%~
END

DEFINE_PATCH_FUNCTION ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_SPLITM~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
    header_length = 0x38    // 0x38 for item, 0x28 for spell
  RET_ARRAY
    all_resources
BEGIN
  DEFINE_ASSOCIATIVE_ARRAY all_resources BEGIN
  END
  READ_LONG 0x6a fx_off
  PATCH_IF (check_globals = 1) BEGIN
    READ_SHORT 0x70 fx_num
    FOR (index = 0 ; index < fx_num ; ++index) BEGIN
      READ_SHORT (fx_off +        (index * 0x30)) opcode_file
      READ_ASCII (fx_off + 0x14 + (index * 0x30)) res_name
      PATCH_IF (match_opcode = opcode_file) AND NOT VARIABLE_IS_SET $all_resources("%res_name%") BEGIN
        SPRINT $all_resources("%res_name%") "set"
      END
    END
  END
  PATCH_IF (check_headers = 1) BEGIN
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    SET loop_start = 0
    SET loop_end = abil_num
    FOR (index2 = loop_start ; index2 < loop_end ; ++index2) BEGIN // looks through headers
      READ_BYTE (abil_off +        (index2 * header_length)) abil_type
      READ_SHORT (abil_off + 0x1e + (index2 * header_length)) abil_fx_num
      READ_SHORT (abil_off + 0x20 + (index2 * header_length)) abil_fx_idx
      FOR (index = 0 ; index < abil_fx_num ; index = index + 1) BEGIN
        READ_SHORT (fx_off +        ((abil_fx_idx + index) * 0x30)) opcode_file
        READ_ASCII (fx_off + 0x14 + ((index + abil_fx_idx) * 0x30)) res_name
        PATCH_IF (~%match_opcode%~ = ~%opcode_file%~) AND NOT VARIABLE_IS_SET $all_resources("%res_name%") BEGIN
          TO_UPPER res_name
          SPRINT $all_resources("%res_name%") "set"
        END
      END
    END
  END
END

DEFINE_PATCH_FUNCTION ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_ITEM~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
  RET_ARRAY
    all_resources
BEGIN
  LPF ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_SPLITM~
    INT_VAR
      check_globals  = 1
      check_headers  = 1
      match_opcode   = %match_opcode%
      header_length = 0x38
    RET_ARRAY 
      all_resources
  END
END

DEFINE_PATCH_FUNCTION ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_SPELL~
  INT_VAR
    check_globals  = 1      // check global effects: 0 for no, 1 for yes
    check_headers  = 1      // check effects on headers; 0 for no, 1 for yes
    match_opcode   = 177    // opcode at 0x00 to match, use -1 for all
  RET_ARRAY
    all_resources
BEGIN
  LPF ~S!GET_ALL_RESOURCES_FOR_GIVEN_OPCODE_OF_SPLITM~
    INT_VAR
      check_globals  = 1
      check_headers  = 1
      match_opcode   = %match_opcode%
      header_length = 0x28
    RET_ARRAY
      all_resources
  END
END

DEFINE_ACTION_FUNCTION ~S!ADD_CLAB_ROW~
  STR_VAR
    filename = ~~
    row_desc = ~~
    level1   = ~****~
    level2   = ~****~
    level3   = ~****~
    level4   = ~****~
    level5   = ~****~
    level6   = ~****~
    level7   = ~****~
    level8   = ~****~
    level9   = ~****~
    level10  = ~****~
    level11  = ~****~
    level12  = ~****~
    level13  = ~****~
    level14  = ~****~
    level15  = ~****~
    level16  = ~****~
    level17  = ~****~
    level18  = ~****~
    level19  = ~****~
    level20  = ~****~
    level21  = ~****~
    level22  = ~****~
    level23  = ~****~
    level24  = ~****~
    level25  = ~****~
    level26  = ~****~
    level27  = ~****~
    level28  = ~****~
    level29  = ~****~
    level30  = ~****~
    level31  = ~****~
    level32  = ~****~
    level33  = ~****~
    level34  = ~****~
    level35  = ~****~
    level36  = ~****~
    level37  = ~****~
    level38  = ~****~
    level39  = ~****~
    level40  = ~****~
BEGIN
  COPY_EXISTING ~%filename%~ ~override~
    COUNT_2DA_COLS ~colcount~
    COUNT_2DA_ROWS ~colcount~ ~rowcount~
    PATCH_IF ~%row_desc%~ STR_EQ ~~ BEGIN
      new_row_value = %rowcount% + 1
      SPRINT row_description ~ABILITY%new_row_value%~
    END
    ELSE BEGIN
      SPRINT row_description ~%row_desc%~
    END
    INSERT_2DA_ROW ~rowcount~ ~colcount~ ~%row_description% %level1%  %level2%  %level3%  %level4%  %level5%  %level6%  %level7%  %level8%  %level9%  %level10%  %level11%  %level12%  %level13%  %level14%  %level15%  %level16%  %level17%  %level18%  %level19%  %level20%  %level21%  %level22%  %level23%  %level24%  %level25%  %level26%  %level27%  %level28%  %level29%  %level30%  %level31%  %level32%  %level33%  %level34%  %level35%  %level36%  %level37%  %level38%  %level39%  %level40%~
    PRETTY_PRINT_2DA
  BUT_ONLY
  IF_EXISTS
END

// DEFINE_ACTION_FUNCTION ~S!ADD_HLA_ROW~
//   STR_VAR
//     filename           = ~~
//     row_desc           = ~~
//     ability            = ~*~
//     icon               = ~*~
//     strref             = ~*~
//     min_level          = ~1~
//     max_level          = ~99~
//     num_allowed        = ~1~
//     prerequisite       = ~*~
//     excluded_by        = ~*~
//     alignment_restrict = ~*~
// BEGIN
//   COPY_EXISTING ~%filename%~ ~override~
//     COUNT_2DA_COLS ~colcount~
//     COUNT_2DA_ROWS ~colcount~ ~rowcount~
//     PATCH_IF ~%row_desc%~ STR_EQ ~~ BEGIN
//       new_row_value = %rowcount% + 1
//       SPRINT row_description ~%new_row_value%~
//     END
//     ELSE BEGIN
//       SPRINT row_description ~%row_desc%~
//     END
//     INSERT_2DA_ROW ~rowcount~ ~colcount~ ~%row_description% %ability%  %icon%  %strref%  %min_level%  %max_level%  %num_allowed%  %prerequisite%  %excluded_by%  %alignment_restrict%~
//     PRETTY_PRINT_2DA
//   BUT_ONLY
//   IF_EXISTS
// END

DEFINE_ACTION_FUNCTION ~S!ADD_HLA_ROW~
  STR_VAR
    filename           = ~~
    row_desc           = ~~
    ability            = ~*~
    icon               = ~*~
    strref             = ~*~
    min_level          = ~1~
    max_level          = ~99~
    num_allowed        = ~1~
    prerequisite       = ~*~
    excluded_by        = ~*~
    alignment_restrict = ~*~
BEGIN
  COPY_EXISTING ~%filename%~ ~override~
    COUNT_2DA_COLS ~colcount~
    COUNT_2DA_ROWS ~colcount~ ~rowcount~
    SPRINT are_all_rows_filled ~TRUE~

    PATCH_IF ~%row_desc%~ STR_EQ ~~ BEGIN
      new_row_value = %rowcount% + 1
      SPRINT row_description ~%new_row_value%~
    END
    ELSE BEGIN
      SPRINT row_description ~%row_desc%~
    END
    READ_2DA_ENTRIES_NOW ~_read_%SOURCE_RES%~ ~colcount~
    FOR (current_row=0; current_row<%rowcount%; ++current_row) BEGIN
      READ_2DA_ENTRY_FORMER ~_read_%SOURCE_RES%~ %current_row% 1 ability_name
      PATCH_IF ~%ability_name%~ STR_EQ ~*~ BEGIN
        REMOVE_2DA_ROW current_row ~colcount~ // First unused row
        INSERT_2DA_ROW current_row ~colcount~ ~%row_description% %ability%  %icon%  %strref%  %min_level%  %max_level%  %num_allowed%  %prerequisite%  %excluded_by%  %alignment_restrict%~
        SET current_row = ~rowcount~
        SPRINT are_all_rows_filled ~FALSE~
      END
    END
    PATCH_IF are_all_rows_filled STR_EQ ~TRUE~ BEGIN
      INSERT_2DA_ROW ~rowcount~ ~colcount~ ~%row_description% %ability%  %icon%  %strref%  %min_level%  %max_level%  %num_allowed%  %prerequisite%  %excluded_by%  %alignment_restrict%~
    END
    PRETTY_PRINT_2DA
  BUT_ONLY
  IF_EXISTS
END

DEFINE_ACTION_FUNCTION ~S!ADD_PORTRAIT_ICON~
  INT_VAR
    description_str_ref = ~-1~
  STR_VAR
    bam_file = ~~
  RET
    portrait_icon_id
BEGIN
  COPY_EXISTING ~statdesc.2da~ ~override~
    COUNT_2DA_COLS ~colcount~
    COUNT_2DA_ROWS ~colcount~ ~rowcount~

    INSERT_2DA_ROW %rowcount% ~colcount~ ~%rowcount%         0         %bam_file%~
    SET_2DA_ENTRY %rowcount% 1 ~colcount~ ~%description_str_ref%~
    SET portrait_icon_id = %rowcount%
    PRETTY_PRINT_2DA
END

/// add a new spell state to splstate.ids ///
// https://www.gibberlings3.net/forums/topic/31421-how-to-get-hla-to-alter-other-abilities/
// thanks to Ardanis (supposedly), who's credited with the authorship of the function in the thread above
DEFINE_ACTION_FUNCTION resolve_state
  INT_VAR index=0 delete=0
  STR_VAR new_state_id = ~blah~
  RET new_state_index
BEGIN
  OUTER_SET min_new = 127

  COPY_EXISTING ~splstate.ids~ override
    new_state_index = 0
    found = 0

    READ_2DA_ENTRIES_NOW stats 2
    FOR (row=0; row<stats; row+=1) BEGIN
      READ_2DA_ENTRY_FORMER stats row 0 ind
      READ_2DA_ENTRY_FORMER stats row 1 str

      SET $stat("%row%") = ind

      PATCH_IF index BEGIN
        PATCH_IF ind = index BEGIN
          REMOVE_2DA_ROW row 2
          found = 1

          PATCH_IF delete = 0 BEGIN
            INSERT_2DA_ROW row 2 ~%index% %new_state_id%~
          END

          row = stats
        END
      END ELSE BEGIN
        PATCH_IF ~%str%~ STRING_EQUAL_CASE ~%new_state_id%~ BEGIN
          new_state_index = ind
          found = 1
          /* row=stats */ // don't stop looking, the same ID may be assigned to a greater index, which takes priority when compiling
        END
      END
    END

    PATCH_IF found = 0 BEGIN
      new_state_index = min_new

      PHP_EACH stat AS row => ind BEGIN
        PATCH_IF found = 0 && (row+1 < stats) BEGIN // not at the end of file
          next_row = row + 1
          next_ind = EVAL $stat("%next_row%")

          PATCH_IF index BEGIN
            PATCH_IF index<next_ind && index>ind BEGIN
              INSERT_2DA_ROW next_row 2 ~%index% %new_state_id%~
              found = 1
            END
          END ELSE BEGIN
            PATCH_IF new_state_index < next_ind BEGIN
              PATCH_IF ind < new_state_index BEGIN
                INSERT_2DA_ROW next_row 2 ~%new_state_index% %new_state_id%~
                found = 1
              END ELSE BEGIN
                new_state_index += 1

                PATCH_IF new_state_index < next_ind BEGIN
                  INSERT_2DA_ROW next_row 2 ~%new_state_index% %new_state_id%~
                  found = 1
                END
              END
            END
          END
        END ELSE BEGIN // at the end of file
          PATCH_IF found = 0 BEGIN
            PATCH_IF index BEGIN
              INSERT_2DA_ROW stats 2 ~%index% %new_state_id%~
            END ELSE BEGIN
              PATCH_IF new_state_index > ind BEGIN
                INSERT_2DA_ROW stats 2 ~%new_state_index% %new_state_id%~
              END ELSE BEGIN
                new_state_index += 1
                INSERT_2DA_ROW stats 2 ~%new_state_index% %new_state_id%~
              END
            END
          END
        END
      END
    END
END

// Copied from CamDawg's ALTER_EFFECT available here https://github.com/WeiDUorg/weidu/blob/devel/src/tph/include/cd_functions.tpa
// This version allows for matching and setting negative values for parameter1 and 2
DEFINE_PATCH_FUNCTION ~S!ALTER_EFFECT~

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0
          silent              = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-999"
          match_parameter2    = "-999"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-999"
          match_special       = "-999"

  // variables for the new effect
          opcode              = "-1"
          target              = "-1"
          power               = "-1"
          parameter1          = "-999"
          parameter2          = "-999"
          timing              = "-1"
          resist_dispel       = "-1"
          duration            = "-1"
          duration_high       = "-1"
          probability1        = "-1"
          probability2        = "-1"
          dicenumber          = "-1"
          dicesize            = "-1"
          savingthrow         = "-1"
          savebonus           = "-999"
          special             = "-999"

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
          resource            = "SAME"

BEGIN  

  // set variables and offsets based on the file type
  SET alter = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  READ_ASCII 0x04 version (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.0" = 0) BEGIN // iwd2, spl 2.0
        SET min_size       = 0x82
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      PATCH_IF (check_headers = 0) BEGIN
        SET abil_num = 0
      END ELSE BEGIN
        READ_LONG   0x64 abil_off ELSE 0
        READ_SHORT  0x68 abil_num ELSE 0
      END
    END

    "ITM "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.1" = 0) BEGIN // pst, itm v1.1
        SET min_size       = 0x9a
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      PATCH_IF (check_headers = 0) BEGIN
        SET abil_num = 0
      END ELSE BEGIN
        READ_LONG   0x64 abil_off ELSE 0
        READ_SHORT  0x68 abil_num ELSE 0
      END
    END

    "CRE "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
        SET min_size       = 0x378
        READ_LONG  0x368 fx_off ELSE 0
        SET counter_offset = 0x36c
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
        SET min_size       = 0x62e
        READ_LONG  0x61e fx_off ELSE 0
        SET counter_offset = 0x622
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
        SET min_size       = 0x33c
        READ_LONG  0x32c fx_off ELSE 0
        SET counter_offset = 0x330
      END ELSE BEGIN                                               // everything else, cre v1.0
        SET min_size = 0x2d4
        READ_LONG  0x2c4 fx_off ELSE 0
        SET counter_offset = 0x2c8
      END
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      SET abil_length = 0
      SET check_globals = 1
      READ_BYTE 0x33 fx_type ELSE 2
    END

    "fail"
    BEGIN
      PATCH_WARN "WARNING: ALTER_EFFECT does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_WARN "WARNING: ALTER_EFFECT does not support file type %sig%"
  END

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_BYTE   (abil_off +        (abil_length * index)) abil_type
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0))) BEGIN                               // and only on the right # header, if specified
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < counter ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          // match ALL these variables, if specified
          PATCH_IF (((match_opcode        = o_opcode)        OR (match_opcode < 0))        AND
                    ((match_target        = o_target)        OR (match_target < 0))        AND
                    ((match_power         = o_power)         OR (match_power < 0))         AND
                    ((match_parameter1    = o_parameter1)    OR (match_parameter1 = ~-999~))    AND
                    ((match_parameter2    = o_parameter2)    OR (match_parameter2 = ~-999~))    AND
                    ((match_timing        = o_timing)        OR (match_timing < 0))        AND
                    ((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0)) AND
                    ((match_duration      = o_duration)      OR (match_duration < 0))      AND
                    ((match_probability1  = o_probability1)  OR (match_probability1 < 0))  AND
                    ((match_probability2  = o_probability2)  OR (match_probability2 < 0))  AND
                    ((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))    AND
                    ((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))      AND
                    ((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))   AND
                    ((match_savebonus     = o_savebonus)     OR (match_savebonus = ~-999~)) AND
                    ((match_special       = o_special)       OR (match_special = ~-999~))       AND
                    (("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0))) BEGIN

            // lazily re-use code
            SET base = (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type))))

            // overwrite the cloned effect with the new variables, if specified
            PATCH_IF (opcode >= 0)        BEGIN WRITE_SHORT (base        + (0x08 * fx_type)) opcode        END
            PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (base + 0x02 + (0x0a * fx_type)) target        END
            PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (base + 0x03 + (0x0d * fx_type)) power         END
            PATCH_IF (parameter1 > ~-999~)    BEGIN WRITE_LONG  (base + 0x04 + (0x10 * fx_type)) parameter1    END
            PATCH_IF (parameter2 > ~-999~)    BEGIN WRITE_LONG  (base + 0x08 + (0x10 * fx_type)) parameter2    END
            PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (base + 0x0c + (0x10 * fx_type)) timing        END
            PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (base + 0x0d + (0x47 * fx_type)) resist_dispel END
            PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (base + 0x0e + (0x12 * fx_type)) duration      END
            PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (base + 0x12 + (0x12 * fx_type)) probability1  END
            PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (base + 0x13 + (0x13 * fx_type)) probability2  END
            PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (base + 0x1c + (0x14 * fx_type)) dicenumber    END
            PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (base + 0x20 + (0x14 * fx_type)) dicesize      END
            PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (base + 0x24 + (0x14 * fx_type)) savingthrow   END
            PATCH_IF (savebonus > ~-999~) BEGIN WRITE_LONG  (base + 0x28 + (0x14 * fx_type)) savebonus     END
            PATCH_IF (special > ~-999~)       BEGIN WRITE_LONG  (base + 0x2c + (0x14 * fx_type)) special       END
            PATCH_IF ("%resource%" STRING_COMPARE_CASE "SAME" != 0) BEGIN
              WRITE_ASCIIE (base + 0x14 + (0x14 * fx_type)) "%resource%" #8
            END

            // update the tracking vars
            SET alter += 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers
    END // end loop through effects on ability
  END // end ability loop

  PATCH_IF (alter = 0 && !silent) BEGIN
    PATCH_WARN "WARNING: no effects altered on %SOURCE_FILE%"
  END

  PATCH_IF (verbose && !silent) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %alter% effect(s) altered"
  END

END